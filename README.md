# Métodos Númericos

## índice
+ Introducción
+ [Tema 1: Introducción a los métodos numéricos.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/blob/main/README.md#tema-1-introducci%C3%B3n-a-los-m%C3%A9todos-num%C3%A9ricos)
  - [Overflow.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/blob/main/README.md#overflow)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Redondeo.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#redondeo)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Truncamiento.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#truncamiento)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
+ [Tema 2: Métodos de solución de ecuaciones.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#tema-2-m%C3%A9todos-de-soluci%C3%B3n-de-ecuaciones)
  - [Bisección.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#bisecci%C3%B3n)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Regla falsa.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#regla-falsa)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Secante.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#secante)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
+ [Tema 3: Métodos de solución de sistemas de ecuaciones.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#tema-3-m%C3%A9todos-de-soluci%C3%B3n-de-sistemas-de-ecuaciones)
  - [Eliminación Gaussiana.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#eliminaci%C3%B3n-gaussiana)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Gauss-Jordan.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#gauss-jordan)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Gauss-Seidel.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#gauss-seidel)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Jacobi.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#jacobi)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
+ [Tema 4: Diferenciación e integración numérica.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#tema-4-diferenciaci%C3%B3n-e-integraci%C3%B3n-num%C3%A9rica)
  - [Simpson 1/3.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#simpson-13)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Simpson 3/8.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#simpson-38)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Trapecio.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#trapecio)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
+ [Tema 5: Interpolación y ajuste de funciones.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#tema-5-interpolaci%C3%B3n-y-ajuste-de-funciones)
  - [Interpolación cuadrática.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#interpolaci%C3%B3n-cuadr%C3%A1tica)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Interpolación lineal.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#interpolaci%C3%B3n-lineal)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Lagrange.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#lagrange)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Newton.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#newton)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
+ [Tema 6: Solución de ecuaciones diferenciales.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#tema-6-soluci%C3%B3n-de-ecuaciones-diferenciales)
  - [Euler.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#euler)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Runge-Kutta.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#runge-kutta)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.
  - [Taylor.](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main#taylor)
      - Definición.
      - Algoritmo.
      - Código en Java.
      - Ejercicios.

# Introducción
Los métodos numéricos son técnicas matemáticas que permiten encontrar soluciones aproximadas a problemas complejos que no pueden resolverse de manera analítica. Estos métodos son fundamentales en diversas áreas de la ingeniería, la física, la economía y otras disciplinas que requieren soluciones precisas a problemas matemáticos complicados. En este repositorio, exploraremos una variedad de métodos numéricos, desde los más básicos hasta los más avanzados, implementados en el lenguaje de programación Java.

********************************************************************************************************************************************
********************************************************************************************************************************************
********************************************************************************************************************************************

# Tema 1: Introducción a los Métodos Numéricos
Este primer tema proporciona una base sólida sobre conceptos esenciales como el overflow, el redondeo y el truncamiento. Se define cada concepto, se explica el algoritmo correspondiente y se proporciona código en Java junto con ejercicios prácticos.
# Overflow.
## Definición
El overflow (desbordamiento) es un fenómeno que ocurre en los cálculos numéricos cuando un resultado excede el rango máximo que puede ser representado por el tipo de dato utilizado en un sistema informático. Esto puede provocar resultados incorrectos y comportamientos inesperados en los programas.

## Algoritmo
1. Definir los límites del tipo de dato.
2. Verificar las condiciones de overflow antes de realizar la operación.
3. Implementar la lógica para lanzar una excepción o manejar el overflow si se detecta.

```
function safeAdd(x, y):
    if x > 0 and y > 0 and x > MAX_INT - y:
        throw OverflowException("Overflow positivo detectado")
    else if x < 0 and y < 0 and x < MIN_INT - y:
        throw OverflowException("Overflow negativo detectado")
    else:
        return x + y

function main():
    a = MAX_INT
    b = 1
    
    try:
        result = safeAdd(a, b)
        print("Resultado de la suma: " + result)
    except OverflowException as e:
        print("Overflow detectado: " + e.message)
```
## Código en Java
```
public class Overflow {
    public static void main(String[] args) {
        // Ejemplo de desbordamiento en operaciones aritméticas con enteros
        int a = Integer.MAX_VALUE; // Valor máximo para un entero
        int b = 1; // Incremento en 1

        // Intentamos incrementar el valor máximo de un entero
        int suma = a + b;

        // Imprimimos el resultado
        System.out.println("Resultado de la suma: " + suma); // Se produce un desbordamiento
    }
}
```
### Salida
![Captura de pantalla (374)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/6f3ccc8e-502d-4196-b214-1b5e7ae937a9)
## Ejercicios
[Enlace de ejercicios](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main/Tema%201/Overflow) 

********************************************************************************************************************************************

# Redondeo.
## Definición.
El redondeo es una técnica utilizada en aritmética y computación para reducir el número de cifras significativas de un número, ajustándolo al valor más cercano con una precisión especificada. Este proceso es comúnmente empleado para manejar la representación de números en sistemas digitales, donde es necesario limitar la cantidad de dígitos debido a restricciones de memoria o precisión.
## Algoritmo.
1. Obtener el número decimal a redondear.
2. Separar la parte entera y la parte fraccionaria del número.
3. Evaluar la parte fraccionaria:
  Si la parte fraccionaria es mayor o igual a 0.5, aumentar la parte entera en 1.
  Si la parte fraccionaria es menor a 0.5, mantener la parte entera sin cambios.
4. El resultado es la parte entera ajustada según el paso anterior.
   
```
function roundToNearestInteger(number):
    // Separar la parte entera y la parte fraccionaria
    integerPart = floor(number)
    fractionalPart = number - integerPart

    // Evaluar la parte fraccionaria
    if fractionalPart >= 0.5:
        return integerPart + 1
    else:
        return integerPart

function main():
    number = 3.7
    result = roundToNearestInteger(number)
    print("Número original: " + number)
    print("Número redondeado: " + result)

```
## Código en Java.
```
public class Redondeo {
    public static void main(String[] args) {
        // Ejemplo de error de redondeo en suma
        double num1 = 0.1;
        double num2 = 0.2;
        double suma = num1 + num2;

        System.out.println("Suma: " + suma); // Imprime 0.30000000000000004

        // Ejemplo de error de redondeo en multiplicación
        double num3 = 1.0 / 3.0;
        double resultado = num3 * 3;

        System.out.println("Resultado: " + resultado); // Imprime 0.9999999999999999
    }
}
```
### Salida
![Captura de pantalla (375)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/f554669d-c8f3-4c87-932a-f8e4a9af4533)
## Ejercicios
[Enlace de ejercicios](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main/Tema%201/Redondeo)

********************************************************************************************************************************************
# Truncamiento.
## Definición.
El truncamiento es una técnica utilizada en aritmética y computación para reducir el número de cifras decimales de un número sin redondear. Se elimina la parte fraccionaria del número, acercándolo al valor entero más cercano hacia cero. Este proceso es útil en situaciones donde se requiere un valor entero sin importar el valor de la parte fraccionaria.
## Algoritmo.
1. Obtener el número decimal a truncar.
2. Separar la parte entera del número.
3. Eliminar la parte fraccionaria del número.
4. El resultado es la parte entera del número.
   
```
function truncateNumber(number):
    // Separar la parte entera
    integerPart = floor(abs(number))

    // Restaurar el signo del número original
    if number < 0:
        return -integerPart
    else:
        return integerPart

function main():
    number = 3.7
    result = truncateNumber(number)
    print("Número original: " + number)
    print("Número truncado: " + result)

    number = -3.7
    result = truncateNumber(number)
    print("Número original: " + number)
    print("Número truncado: " + result)
```
## Código en Java.
```
public class Truncamiento {
    public static void main(String[] args) {
        // Ejemplo de error de truncamiento en la aproximación de una serie infinita
        int n = 10; // Número de términos a considerar en la serie
        double x = 0.5; // Valor en el que evaluamos la serie
        double suma = 0.0;

        for (int i = 0; i < n; i++) {
            suma += Math.pow(-1, i) * Math.pow(x, 2 * i + 1) / factorial(2 * i + 1);
        }

        System.out.println("Aproximación de la serie: " + suma); // Imprime un valor aproximado
    }

    // Método para calcular el factorial de un número
    public static int factorial(int n) {
        int fact = 1;
        for (int i = 1; i <= n; i++) {
            fact *= i;
        }
        return fact;
    }
}
```
### Salida
![Captura de pantalla (376)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/488313b6-a23e-4347-9aae-8abcdfb1cab3)
## Ejercicios
[Enlace de ejercicios](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main/Tema%201/Truncamiento)
********************************************************************************************************************************************
********************************************************************************************************************************************
********************************************************************************************************************************************

# Tema 2: Métodos de Solución de Ecuaciones
Aquí se exploran técnicas para resolver ecuaciones no lineales. Los métodos de bisección, regla falsa y secante se presentan con sus definiciones, algoritmos detallados, implementaciones en Java y ejercicios prácticos.
# Bisección.
## Definición.
El método de bisección es un método numérico utilizado para encontrar las raíces de una función continua. Consiste en dividir repetidamente un intervalo en dos partes y seleccionar el subintervalo en el que existe un cambio de signo de la función, lo que indica la presencia de una raíz. Este proceso se repite hasta que se alcanza un intervalo suficientemente pequeño, proporcionando una aproximación de la raíz.
## Algoritmo.
1. Definir la función ( f(x) ) y los extremos del intervalo ([a, b]) tal que ( f(a) \cdot f(b) < 0 ).
2. Calcular el punto medio ( c = \frac{a + b}{2} ).
3. Evaluar ( f(c) ).
Si ( f(c) = 0 ) o el intervalo es suficientemente pequeño (criterio de convergencia), entonces ( c ) es la raíz.
Si ( f(a) \cdot f(c) < 0 ), entonces la raíz está en el intervalo ([a, c]). De lo contrario, la raíz está en ([c, b]).
4. Repetir el proceso con el nuevo intervalo hasta que se cumpla el criterio de convergencia.

```
function bisection(f, a, b, epsilon):
    if f(a) * f(b) >= 0:
        throw Exception("El intervalo no contiene una raíz")

    while (b - a) / 2 > epsilon:
        c = (a + b) / 2
        if f(c) == 0:
            return c // La raíz exacta es encontrada
        if f(a) * f(c) < 0:
            b = c
        else:
            a = c

    return (a + b) / 2 // Aproximación de la raíz

function main():
    // Definir la función f(x)
    function f(x):
        return x^3 - x - 2

    // Definir el intervalo inicial [a, b] y la tolerancia epsilon
    a = 1
    b = 2
    epsilon = 0.0001

    try:
        root = bisection(f, a, b, epsilon)
        print("La raíz aproximada es: " + root)
    except Exception as e:
        print(e.message)
```  
## Código en Java.
```
/*
 * Descripcion del ejemplo

    Función: x^3+4x^2-10    Limites: A:1 B:2    Error: 0.0001    Iteraciones: 6

    Implementacion (resultado a 5 cifras significativas)

    1.36719
 * 
 */

import java.util.Scanner;
public class Biseccion {
    public static void main(String[] args) {
        System.out.println(" EJECICIO 1 METODO DE BISECCION ");
        // Crear un objeto Scanner para leer la entrada del usuario
        Scanner scanner = new Scanner(System.in);

        System.out.print("Ingrese el límite inferior: ");
        double a = scanner.nextDouble();

        System.out.print("Ingrese el límite superior: ");
        double b = scanner.nextDouble();

        // Pedir al usuario que ingrese el número máximo de iteraciones
        System.out.print("Ingrese el número máximo de iteraciones: ");
        int maxIter = scanner.nextInt();

        // Pedir al usuario que ingrese el valor de tolerancia (error aceptable)
        System.out.print("Ingrese el valor de tolerancia: ");
        // Leer el valor de tolerancia (error aceptable) desde el usuario
        double tol = scanner.nextDouble();

        // Encontrar la raíz de la función usando el método de bisección
        double root = bisectionMethod(a, b, maxIter, tol);

        // Imprimir el resultado
        System.out.printf("La raíz de la ecuación es: %.5f%n", root);
        /*
         Esta parte %.5f%n sirve para dejar el numero decimal con 5 digitos despues del punto decimal
        */
    }

    // Definir el método de bisección
    public static double bisectionMethod(double a, double b, int maxIter, double tol) {
        // Verificar si la función cambia de signo en el intervalo
        if ((func(a) * func(b)) > 0) {
            System.out.println("El método no puede encontrar una raíz en el intervalo.");
            return -1;
        }

        double c;
        // repetir hasta que se alcance el número máximo de iteraciones
        for (int i = 0; i < maxIter; i++) {
            // Calcular el punto medio del intervalo
            c = (a + b) / 2;
            // Verificar si el punto medio está dentro de la tolerancia (error aceptable)
            if (Math.abs(func(c)) < tol) {
                // Devolver el punto medio como la raíz
                return c;
            }
            // Actualizar el intervalo
            if (func(a) * func(c) < 0) {
                b = c;
            } else {
                a = c;
            }
        }
        // Devolver el punto medio del intervalo final como la raíz
        return (a + b) / 2;
    }

    // Definir la función para encontrar la raíz de
    public static double func(double x) {
        return Math.pow(x, 3) + 4 * Math.pow(x, 2) - 10;
    }
}
```
### Salida
![Captura de pantalla (377)](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/assets/147757830/c239f15a-eaf3-4ef5-a441-d196be505e15)

## Ejercicios
[Enlace de ejercicios](https://github.com/AlanOrgazVillegas/MetodosNumericos_T6/tree/main/Tema%202/Bisecci%C3%B3n)
********************************************************************************************************************************************
# Regla Falsa.
## Definición.

## Algoritmo.

## Código en Java.

### Salida

## Ejercicios

********************************************************************************************************************************************
# Secante.
## Definición.

## Algoritmo.

## Código en Java.

### Salida

## Ejercicios

********************************************************************************************************************************************
********************************************************************************************************************************************
********************************************************************************************************************************************

# Tema 3: Métodos de Solución de Sistemas de Ecuaciones
Este tema aborda métodos para resolver sistemas de ecuaciones lineales. Se incluyen la eliminación gaussiana, Gauss-Jordan, Gauss-Seidel y Jacobi.
# Eliminación Gaussiana.
## Definición.

## Algoritmo.

## Código en Java.

### Salida

## Ejercicios

********************************************************************************************************************************************
# Gauss-Jordan.
## Definición.

## Algoritmo.

## Código en Java.

### Salida

## Ejercicios

********************************************************************************************************************************************
# Gauss-Seidel.
## Definición.

## Algoritmo.

## Código en Java.

### Salida

## Ejercicios

********************************************************************************************************************************************
# Jacobi.
## Definición.

## Algoritmo.

## Código en Java.

### Salida

## Ejercicios

********************************************************************************************************************************************
********************************************************************************************************************************************
********************************************************************************************************************************************

# Tema 4: Diferenciación e Integración Numérica
Aquí se cubren métodos para la diferenciación e integración de funciones. Se incluyen los métodos de Simpson 1/3, Simpson 3/8 y el método del trapecio.

# Simpson 1/3.
## Definición.

## Algoritmo.

## Código en Java.

### Salida

## Ejercicios

********************************************************************************************************************************************
# Simpson 3/8.
## Definición.

## Algoritmo.

## Código en Java.

### Salida

## Ejercicios
********************************************************************************************************************************************
# Trapecio.
## Definición.

## Algoritmo.

## Código en Java.

### Salida

## Ejercicios

********************************************************************************************************************************************
# Tema 5: Interpolación y Ajuste de Funciones
En este tema se estudian técnicas de interpolación y ajuste de funciones, como la interpolación cuadrática, lineal, de Lagrange y de Newton.

# Interpolación Cuadrática.
## Definición.

## Algoritmo.

## Código en Java.

### Salida

## Ejercicios

********************************************************************************************************************************************
# Interpolación Lineal.
## Definición.

## Algoritmo.

## Código en Java.

### Salida

## Ejercicios

********************************************************************************************************************************************
# Lagrange.
## Definición.

## Algoritmo.

## Código en Java.

### Salida

## Ejercicios

********************************************************************************************************************************************
# Newton.
## Definición.

## Algoritmo.

## Código en Java.

### Salida

## Ejercicios

********************************************************************************************************************************************
********************************************************************************************************************************************
********************************************************************************************************************************************

# Tema 6: Solución de Ecuaciones Diferenciales
Finalmente, se presentan métodos numéricos para la solución de ecuaciones diferenciales, incluyendo los métodos de Euler, Runge-Kutta y Taylor.

# Euler.
## Definición.

## Algoritmo.

## Código en Java.

### Salida

## Ejercicios

********************************************************************************************************************************************
# Runge-Kutta.
## Definición.

## Algoritmo.

## Código en Java.

### Salida

## Ejercicios

********************************************************************************************************************************************
# Taylor.
## Definición.

## Algoritmo.

## Código en Java.

### Salida

## Ejercicios

********************************************************************************************************************************************

Cada tema está estructurado para ofrecer una comprensión completa del método, proporcionando definiciones claras, algoritmos detallados, ejemplos de código en Java y ejercicios prácticos para consolidar el aprendizaje. Esperamos que este repositorio sea una herramienta útil para estudiantes y profesionales interesados en el fascinante campo de los métodos numéricos.
